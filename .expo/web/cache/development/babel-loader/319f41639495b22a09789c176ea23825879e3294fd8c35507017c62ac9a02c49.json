{"ast":null,"code":"var _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar _excluded = [\"password\"];\nvar express = require('express');\nvar bcrypt = require('bcryptjs');\nvar jwt = require('jsonwebtoken');\nvar prisma = require(\"../prisma\");\nvar router = express.Router();\nvar authenticateToken = function authenticateToken(req, res, next) {\n  var authHeader = req.headers['authorization'];\n  var token = authHeader && authHeader.split(' ')[1];\n  if (!token) {\n    return res.status(401).json({\n      success: false,\n      message: 'Token de acesso necessário'\n    });\n  }\n  jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret', function (err, user) {\n    if (err) {\n      return res.status(403).json({\n        success: false,\n        message: 'Token inválido ou expirado'\n      });\n    }\n    req.user = user;\n    next();\n  });\n};\nrouter.post('/register', function () {\n  var _ref = _asyncToGenerator(function* (req, res) {\n    try {\n      var _req$body = req.body,\n        name = _req$body.name,\n        email = _req$body.email,\n        password = _req$body.password,\n        age = _req$body.age,\n        school = _req$body.school,\n        userClass = _req$body.class,\n        _req$body$userType = _req$body.userType,\n        userType = _req$body$userType === void 0 ? 'STUDENT' : _req$body$userType;\n      if (!name || !email || !password) {\n        return res.status(400).json({\n          success: false,\n          message: 'Nome, email e senha são obrigatórios'\n        });\n      }\n      if (password.length < 6) {\n        return res.status(400).json({\n          success: false,\n          message: 'A senha deve ter pelo menos 6 caracteres'\n        });\n      }\n      if (!['STUDENT', 'TEACHER'].includes(userType)) {\n        return res.status(400).json({\n          success: false,\n          message: 'Tipo de usuário inválido'\n        });\n      }\n      var existingUser = yield prisma.user.findUnique({\n        where: {\n          email: email\n        }\n      });\n      if (existingUser) {\n        return res.status(409).json({\n          success: false,\n          message: 'Este email já está cadastrado'\n        });\n      }\n      var hashedPassword = yield bcrypt.hash(password, 12);\n      var user = yield prisma.user.create({\n        data: {\n          name: name,\n          email: email,\n          password: hashedPassword,\n          age: age ? parseInt(age) : null,\n          school: school || null,\n          class: userClass || null,\n          userType: userType\n        },\n        select: {\n          id: true,\n          name: true,\n          email: true,\n          age: true,\n          school: true,\n          class: true,\n          avatar: true,\n          userType: true,\n          createdAt: true\n        }\n      });\n      var token = jwt.sign({\n        userId: user.id,\n        email: user.email,\n        userType: user.userType\n      }, process.env.JWT_SECRET || 'fallback-secret', {\n        expiresIn: '7d'\n      });\n      res.status(201).json({\n        success: true,\n        message: 'Usuário criado com sucesso',\n        data: {\n          user: user,\n          token: token\n        }\n      });\n    } catch (error) {\n      console.error('Erro no registro:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  });\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}());\nrouter.post('/login', function () {\n  var _ref2 = _asyncToGenerator(function* (req, res) {\n    try {\n      var _req$body2 = req.body,\n        email = _req$body2.email,\n        password = _req$body2.password,\n        _req$body2$userType = _req$body2.userType,\n        userType = _req$body2$userType === void 0 ? 'STUDENT' : _req$body2$userType;\n      if (!email || !password) {\n        return res.status(400).json({\n          success: false,\n          message: 'Email e senha são obrigatórios'\n        });\n      }\n      var user = yield prisma.user.findUnique({\n        where: {\n          email: email\n        }\n      });\n      if (!user) {\n        return res.status(401).json({\n          success: false,\n          message: 'Credenciais inválidas'\n        });\n      }\n      if (user.userType !== userType) {\n        return res.status(401).json({\n          success: false,\n          message: `Credenciais inválidas para ${userType === 'STUDENT' ? 'estudante' : 'professor'}`\n        });\n      }\n      var isValidPassword = yield bcrypt.compare(password, user.password);\n      if (!isValidPassword) {\n        return res.status(401).json({\n          success: false,\n          message: 'Credenciais inválidas'\n        });\n      }\n      var token = jwt.sign({\n        userId: user.id,\n        email: user.email,\n        userType: user.userType\n      }, process.env.JWT_SECRET || 'fallback-secret', {\n        expiresIn: '7d'\n      });\n      var _ = user.password,\n        userWithoutPassword = _objectWithoutProperties(user, _excluded);\n      res.json({\n        success: true,\n        message: 'Login realizado com sucesso',\n        data: {\n          user: userWithoutPassword,\n          token: token\n        }\n      });\n    } catch (error) {\n      console.error('Erro no login:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  });\n  return function (_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}());\nrouter.get('/verify', authenticateToken, function () {\n  var _ref3 = _asyncToGenerator(function* (req, res) {\n    try {\n      var user = yield prisma.user.findUnique({\n        where: {\n          id: req.user.userId\n        },\n        select: {\n          id: true,\n          name: true,\n          email: true,\n          age: true,\n          school: true,\n          class: true,\n          avatar: true,\n          userType: true,\n          createdAt: true\n        }\n      });\n      if (!user) {\n        return res.status(404).json({\n          success: false,\n          message: 'Usuário não encontrado'\n        });\n      }\n      res.json({\n        success: true,\n        data: {\n          user: user\n        }\n      });\n    } catch (error) {\n      console.error('Erro na verificação:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  });\n  return function (_x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}());\nrouter.post('/logout', function (req, res) {\n  res.json({\n    success: true,\n    message: 'Logout realizado com sucesso'\n  });\n});\nmodule.exports = router;","map":{"version":3,"names":["express","require","bcrypt","jwt","prisma","router","Router","authenticateToken","req","res","next","authHeader","headers","token","split","status","json","success","message","verify","process","env","JWT_SECRET","err","user","post","_ref","_asyncToGenerator","_req$body","body","name","email","password","age","school","userClass","class","_req$body$userType","userType","length","includes","existingUser","findUnique","where","hashedPassword","hash","create","data","parseInt","select","id","avatar","createdAt","sign","userId","expiresIn","error","console","_x","_x2","apply","arguments","_ref2","_req$body2","_req$body2$userType","isValidPassword","compare","_","userWithoutPassword","_objectWithoutProperties","_excluded","_x3","_x4","get","_ref3","_x5","_x6","module","exports"],"sources":["C:/Users/lukag/OneDrive/Área de Trabalho/Muvz_App/api/routes/auth.js"],"sourcesContent":["const express = require('express');\nconst bcrypt = require('bcryptjs');\nconst jwt = require('jsonwebtoken');\nconst prisma = require('../prisma');\n\nconst router = express.Router();\n\n// Middleware para verificar token JWT\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token) {\n    return res.status(401).json({\n      success: false,\n      message: 'Token de acesso necessário'\n    });\n  }\n\n  jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret', (err, user) => {\n    if (err) {\n      return res.status(403).json({\n        success: false,\n        message: 'Token inválido ou expirado'\n      });\n    }\n    req.user = user;\n    next();\n  });\n};\n\n// Registrar usuário\nrouter.post('/register', async (req, res) => {\n  try {\n    const { name, email, password, age, school, class: userClass, userType = 'STUDENT' } = req.body;\n\n    // Validações básicas\n    if (!name || !email || !password) {\n      return res.status(400).json({\n        success: false,\n        message: 'Nome, email e senha são obrigatórios'\n      });\n    }\n\n    if (password.length < 6) {\n      return res.status(400).json({\n        success: false,\n        message: 'A senha deve ter pelo menos 6 caracteres'\n      });\n    }\n\n    // Validar tipo de usuário\n    if (!['STUDENT', 'TEACHER'].includes(userType)) {\n      return res.status(400).json({\n        success: false,\n        message: 'Tipo de usuário inválido'\n      });\n    }\n\n    // Verificar se o email já existe\n    const existingUser = await prisma.user.findUnique({\n      where: { email }\n    });\n\n    if (existingUser) {\n      return res.status(409).json({\n        success: false,\n        message: 'Este email já está cadastrado'\n      });\n    }\n\n    // Hash da senha\n    const hashedPassword = await bcrypt.hash(password, 12);\n\n    // Criar usuário\n    const user = await prisma.user.create({\n      data: {\n        name,\n        email,\n        password: hashedPassword,\n        age: age ? parseInt(age) : null,\n        school: school || null,\n        class: userClass || null,\n        userType\n      },\n      select: {\n        id: true,\n        name: true,\n        email: true,\n        age: true,\n        school: true,\n        class: true,\n        avatar: true,\n        userType: true,\n        createdAt: true\n      }\n    });\n\n    // Gerar token JWT\n    const token = jwt.sign(\n      { userId: user.id, email: user.email, userType: user.userType },\n      process.env.JWT_SECRET || 'fallback-secret',\n      { expiresIn: '7d' }\n    );\n\n    res.status(201).json({\n      success: true,\n      message: 'Usuário criado com sucesso',\n      data: {\n        user,\n        token\n      }\n    });\n\n  } catch (error) {\n    console.error('Erro no registro:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// Login\nrouter.post('/login', async (req, res) => {\n  try {\n    const { email, password, userType = 'STUDENT' } = req.body;\n\n    if (!email || !password) {\n      return res.status(400).json({\n        success: false,\n        message: 'Email e senha são obrigatórios'\n      });\n    }\n\n    // Buscar usuário\n    const user = await prisma.user.findUnique({\n      where: { email }\n    });\n\n    if (!user) {\n      return res.status(401).json({\n        success: false,\n        message: 'Credenciais inválidas'\n      });\n    }\n\n    // Verificar se o tipo de usuário corresponde\n    if (user.userType !== userType) {\n      return res.status(401).json({\n        success: false,\n        message: `Credenciais inválidas para ${userType === 'STUDENT' ? 'estudante' : 'professor'}`\n      });\n    }\n\n    // Verificar senha\n    const isValidPassword = await bcrypt.compare(password, user.password);\n\n    if (!isValidPassword) {\n      return res.status(401).json({\n        success: false,\n        message: 'Credenciais inválidas'\n      });\n    }\n\n    // Gerar token JWT\n    const token = jwt.sign(\n      { userId: user.id, email: user.email, userType: user.userType },\n      process.env.JWT_SECRET || 'fallback-secret',\n      { expiresIn: '7d' }\n    );\n\n    // Retornar dados do usuário (sem senha)\n    const { password: _, ...userWithoutPassword } = user;\n\n    res.json({\n      success: true,\n      message: 'Login realizado com sucesso',\n      data: {\n        user: userWithoutPassword,\n        token\n      }\n    });\n\n  } catch (error) {\n    console.error('Erro no login:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// Verificar token\nrouter.get('/verify', authenticateToken, async (req, res) => {\n  try {\n    const user = await prisma.user.findUnique({\n      where: { id: req.user.userId },\n      select: {\n        id: true,\n        name: true,\n        email: true,\n        age: true,\n        school: true,\n        class: true,\n        avatar: true,\n        userType: true,\n        createdAt: true\n      }\n    });\n\n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        message: 'Usuário não encontrado'\n      });\n    }\n\n    res.json({\n      success: true,\n      data: { user }\n    });\n\n  } catch (error) {\n    console.error('Erro na verificação:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Erro interno do servidor'\n    });\n  }\n});\n\n// Logout (opcional - no JWT, o logout é feito no frontend)\nrouter.post('/logout', (req, res) => {\n  res.json({\n    success: true,\n    message: 'Logout realizado com sucesso'\n  });\n});\n\nmodule.exports = router;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}