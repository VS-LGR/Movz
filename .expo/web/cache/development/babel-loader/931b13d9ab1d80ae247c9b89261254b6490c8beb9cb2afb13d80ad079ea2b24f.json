{"ast":null,"code":"var _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar express = require('express');\nvar prisma = require(\"../prisma\");\nvar authenticateToken = function authenticateToken(req, res, next) {\n  var authHeader = req.headers['authorization'];\n  var token = authHeader && authHeader.split(' ')[1];\n  if (!token) {\n    return res.status(401).json({\n      success: false,\n      message: 'Token de acesso necessário'\n    });\n  }\n  var jwt = require('jsonwebtoken');\n  jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret', function (err, user) {\n    if (err) {\n      return res.status(403).json({\n        success: false,\n        message: 'Token inválido ou expirado'\n      });\n    }\n    req.user = user;\n    next();\n  });\n};\nvar router = express.Router();\nrouter.post('/send', authenticateToken, function () {\n  var _ref = _asyncToGenerator(function* (req, res) {\n    try {\n      var message = req.body.message;\n      var userId = req.user.userId;\n      if (!message || message.trim().length === 0) {\n        return res.status(400).json({\n          success: false,\n          message: 'Mensagem não pode estar vazia'\n        });\n      }\n      if (message.length > 1000) {\n        return res.status(400).json({\n          success: false,\n          message: 'Mensagem muito longa (máximo 1000 caracteres)'\n        });\n      }\n      var chatMessage = yield prisma.chatMessage.create({\n        data: {\n          userId: userId,\n          message: message.trim()\n        },\n        include: {\n          user: {\n            select: {\n              id: true,\n              name: true,\n              avatar: true\n            }\n          }\n        }\n      });\n      res.json({\n        success: true,\n        message: 'Mensagem enviada com sucesso',\n        data: {\n          chatMessage: chatMessage\n        }\n      });\n    } catch (error) {\n      console.error('Erro ao enviar mensagem:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  });\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}());\nrouter.get('/messages', authenticateToken, function () {\n  var _ref2 = _asyncToGenerator(function* (req, res) {\n    try {\n      var _req$query = req.query,\n        _req$query$limit = _req$query.limit,\n        limit = _req$query$limit === void 0 ? 50 : _req$query$limit,\n        _req$query$offset = _req$query.offset,\n        offset = _req$query$offset === void 0 ? 0 : _req$query$offset,\n        before = _req$query.before;\n      var whereClause = {};\n      if (before) {\n        whereClause.createdAt = {\n          lt: new Date(before)\n        };\n      }\n      var messages = yield prisma.chatMessage.findMany({\n        where: whereClause,\n        include: {\n          user: {\n            select: {\n              id: true,\n              name: true,\n              avatar: true\n            }\n          }\n        },\n        orderBy: {\n          createdAt: 'desc'\n        },\n        take: parseInt(limit),\n        skip: parseInt(offset)\n      });\n      var totalCount = yield prisma.chatMessage.count();\n      res.json({\n        success: true,\n        data: {\n          messages: messages.reverse(),\n          pagination: {\n            total: totalCount,\n            limit: parseInt(limit),\n            offset: parseInt(offset),\n            hasMore: parseInt(offset) + parseInt(limit) < totalCount\n          }\n        }\n      });\n    } catch (error) {\n      console.error('Erro ao buscar mensagens:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  });\n  return function (_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}());\nrouter.put('/mark-read', authenticateToken, function () {\n  var _ref3 = _asyncToGenerator(function* (req, res) {\n    try {\n      var userId = req.user.userId;\n      yield prisma.chatMessage.updateMany({\n        where: {\n          userId: {\n            not: userId\n          },\n          isRead: false\n        },\n        data: {\n          isRead: true\n        }\n      });\n      res.json({\n        success: true,\n        message: 'Mensagens marcadas como lidas'\n      });\n    } catch (error) {\n      console.error('Erro ao marcar mensagens como lidas:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  });\n  return function (_x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}());\nrouter.get('/stats', authenticateToken, function () {\n  var _ref4 = _asyncToGenerator(function* (req, res) {\n    try {\n      var userId = req.user.userId;\n      var _yield$Promise$all = yield Promise.all([prisma.chatMessage.count(), prisma.chatMessage.count({\n          where: {\n            userId: {\n              not: userId\n            },\n            isRead: false\n          }\n        }), prisma.chatMessage.count({\n          where: {\n            userId: userId\n          }\n        }), prisma.chatMessage.findMany({\n          take: 5,\n          orderBy: {\n            createdAt: 'desc'\n          },\n          include: {\n            user: {\n              select: {\n                id: true,\n                name: true,\n                avatar: true\n              }\n            }\n          }\n        })]),\n        _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 4),\n        totalMessages = _yield$Promise$all2[0],\n        unreadMessages = _yield$Promise$all2[1],\n        userMessages = _yield$Promise$all2[2],\n        recentActivity = _yield$Promise$all2[3];\n      res.json({\n        success: true,\n        data: {\n          totalMessages: totalMessages,\n          unreadMessages: unreadMessages,\n          userMessages: userMessages,\n          recentActivity: recentActivity\n        }\n      });\n    } catch (error) {\n      console.error('Erro ao buscar estatísticas do chat:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  });\n  return function (_x7, _x8) {\n    return _ref4.apply(this, arguments);\n  };\n}());\nrouter.delete('/:messageId', authenticateToken, function () {\n  var _ref5 = _asyncToGenerator(function* (req, res) {\n    try {\n      var messageId = req.params.messageId;\n      var userId = req.user.userId;\n      var message = yield prisma.chatMessage.findFirst({\n        where: {\n          id: messageId,\n          userId: userId\n        }\n      });\n      if (!message) {\n        return res.status(404).json({\n          success: false,\n          message: 'Mensagem não encontrada ou você não tem permissão para deletá-la'\n        });\n      }\n      yield prisma.chatMessage.delete({\n        where: {\n          id: messageId\n        }\n      });\n      res.json({\n        success: true,\n        message: 'Mensagem deletada com sucesso'\n      });\n    } catch (error) {\n      console.error('Erro ao deletar mensagem:', error);\n      res.status(500).json({\n        success: false,\n        message: 'Erro interno do servidor'\n      });\n    }\n  });\n  return function (_x9, _x0) {\n    return _ref5.apply(this, arguments);\n  };\n}());\nmodule.exports = router;","map":{"version":3,"names":["express","require","prisma","authenticateToken","req","res","next","authHeader","headers","token","split","status","json","success","message","jwt","verify","process","env","JWT_SECRET","err","user","router","Router","post","_ref","_asyncToGenerator","body","userId","trim","length","chatMessage","create","data","include","select","id","name","avatar","error","console","_x","_x2","apply","arguments","get","_ref2","_req$query","query","_req$query$limit","limit","_req$query$offset","offset","before","whereClause","createdAt","lt","Date","messages","findMany","where","orderBy","take","parseInt","skip","totalCount","count","reverse","pagination","total","hasMore","_x3","_x4","put","_ref3","updateMany","not","isRead","_x5","_x6","_ref4","_yield$Promise$all","Promise","all","_yield$Promise$all2","_slicedToArray","totalMessages","unreadMessages","userMessages","recentActivity","_x7","_x8","delete","_ref5","messageId","params","findFirst","_x9","_x0","module","exports"],"sources":["C:/Users/lukag/OneDrive/Área de Trabalho/Muvz_App/api/routes/chat.js"],"sourcesContent":["const express = require('express');\r\nconst prisma = require('../prisma');\r\n// Middleware de autenticação\r\nconst authenticateToken = (req, res, next) => {\r\n  const authHeader = req.headers['authorization'];\r\n  const token = authHeader && authHeader.split(' ')[1];\r\n\r\n  if (!token) {\r\n    return res.status(401).json({\r\n      success: false,\r\n      message: 'Token de acesso necessário'\r\n    });\r\n  }\r\n\r\n  const jwt = require('jsonwebtoken');\r\n  jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret', (err, user) => {\r\n    if (err) {\r\n      return res.status(403).json({\r\n        success: false,\r\n        message: 'Token inválido ou expirado'\r\n      });\r\n    }\r\n    req.user = user;\r\n    next();\r\n  });\r\n};\r\n\r\nconst router = express.Router();\r\n\r\n// Enviar mensagem\r\nrouter.post('/send', authenticateToken, async (req, res) => {\r\n  try {\r\n    const { message } = req.body;\r\n    const userId = req.user.userId;\r\n\r\n    if (!message || message.trim().length === 0) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'Mensagem não pode estar vazia'\r\n      });\r\n    }\r\n\r\n    if (message.length > 1000) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: 'Mensagem muito longa (máximo 1000 caracteres)'\r\n      });\r\n    }\r\n\r\n    const chatMessage = await prisma.chatMessage.create({\r\n      data: {\r\n        userId,\r\n        message: message.trim()\r\n      },\r\n      include: {\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            name: true,\r\n            avatar: true\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'Mensagem enviada com sucesso',\r\n      data: { chatMessage }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Erro ao enviar mensagem:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Erro interno do servidor'\r\n    });\r\n  }\r\n});\r\n\r\n// Buscar mensagens\r\nrouter.get('/messages', authenticateToken, async (req, res) => {\r\n  try {\r\n    const { limit = 50, offset = 0, before } = req.query;\r\n\r\n    const whereClause = {};\r\n    if (before) {\r\n      whereClause.createdAt = {\r\n        lt: new Date(before)\r\n      };\r\n    }\r\n\r\n    const messages = await prisma.chatMessage.findMany({\r\n      where: whereClause,\r\n      include: {\r\n        user: {\r\n          select: {\r\n            id: true,\r\n            name: true,\r\n            avatar: true\r\n          }\r\n        }\r\n      },\r\n      orderBy: { createdAt: 'desc' },\r\n      take: parseInt(limit),\r\n      skip: parseInt(offset)\r\n    });\r\n\r\n    const totalCount = await prisma.chatMessage.count();\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        messages: messages.reverse(), // Ordenar do mais antigo para o mais recente\r\n        pagination: {\r\n          total: totalCount,\r\n          limit: parseInt(limit),\r\n          offset: parseInt(offset),\r\n          hasMore: (parseInt(offset) + parseInt(limit)) < totalCount\r\n        }\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Erro ao buscar mensagens:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Erro interno do servidor'\r\n    });\r\n  }\r\n});\r\n\r\n// Marcar mensagens como lidas\r\nrouter.put('/mark-read', authenticateToken, async (req, res) => {\r\n  try {\r\n    const userId = req.user.userId;\r\n\r\n    await prisma.chatMessage.updateMany({\r\n      where: {\r\n        userId: {\r\n          not: userId\r\n        },\r\n        isRead: false\r\n      },\r\n      data: {\r\n        isRead: true\r\n      }\r\n    });\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'Mensagens marcadas como lidas'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Erro ao marcar mensagens como lidas:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Erro interno do servidor'\r\n    });\r\n  }\r\n});\r\n\r\n// Buscar estatísticas do chat\r\nrouter.get('/stats', authenticateToken, async (req, res) => {\r\n  try {\r\n    const userId = req.user.userId;\r\n\r\n    const [\r\n      totalMessages,\r\n      unreadMessages,\r\n      userMessages,\r\n      recentActivity\r\n    ] = await Promise.all([\r\n      prisma.chatMessage.count(),\r\n      prisma.chatMessage.count({\r\n        where: {\r\n          userId: {\r\n            not: userId\r\n          },\r\n          isRead: false\r\n        }\r\n      }),\r\n      prisma.chatMessage.count({\r\n        where: { userId }\r\n      }),\r\n      prisma.chatMessage.findMany({\r\n        take: 5,\r\n        orderBy: { createdAt: 'desc' },\r\n        include: {\r\n          user: {\r\n            select: {\r\n              id: true,\r\n              name: true,\r\n              avatar: true\r\n            }\r\n          }\r\n        }\r\n      })\r\n    ]);\r\n\r\n    res.json({\r\n      success: true,\r\n      data: {\r\n        totalMessages,\r\n        unreadMessages,\r\n        userMessages,\r\n        recentActivity\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Erro ao buscar estatísticas do chat:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Erro interno do servidor'\r\n    });\r\n  }\r\n});\r\n\r\n// Deletar mensagem (apenas do próprio usuário)\r\nrouter.delete('/:messageId', authenticateToken, async (req, res) => {\r\n  try {\r\n    const { messageId } = req.params;\r\n    const userId = req.user.userId;\r\n\r\n    const message = await prisma.chatMessage.findFirst({\r\n      where: {\r\n        id: messageId,\r\n        userId\r\n      }\r\n    });\r\n\r\n    if (!message) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: 'Mensagem não encontrada ou você não tem permissão para deletá-la'\r\n      });\r\n    }\r\n\r\n    await prisma.chatMessage.delete({\r\n      where: { id: messageId }\r\n    });\r\n\r\n    res.json({\r\n      success: true,\r\n      message: 'Mensagem deletada com sucesso'\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Erro ao deletar mensagem:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: 'Erro interno do servidor'\r\n    });\r\n  }\r\n});\r\n\r\nmodule.exports = router;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}